Problem: 
352. LÃT ÄÆ¯á»œNG
á» Ä‘áº¥t nÆ°á»›c ná» cÃ³ ğ‘› thÃ nh phá»‘ Ä‘Ã¡nh sá»‘ tá»« 1 tá»›i ğ‘› vÃ  ğ‘š con Ä‘Æ°á»ng Ä‘áº¥t ná»‘i chÃºng vá»›i nhau Ä‘Ã¡nh sá»‘ tá»« 1
tá»›i ğ‘š. Con Ä‘Æ°á»ng thá»© ğ‘– tá»« thÃ nh phá»‘ ğ‘¢ğ‘– tá»›i thÃ nh phá»‘ ğ‘£ğ‘– vÃ  cho phÃ©p Ä‘i láº¡i giá»¯a hai thÃ nh phá»‘ Ä‘Ã³ theo cáº£
hai chiá»u. Háº¡ táº§ng giao thÃ´ng cáº§n Ä‘Æ°á»£c nÃ¢ng cáº¥p nhÆ°ng do ngÃ¢n sÃ¡ch nhÃ  nÆ°á»›c cÃ²n eo háº¹p, nhÃ  vua muá»‘n
chá»n ra ğ‘› âˆ’ 1 con Ä‘Æ°á»ng Ä‘á»ƒ lÃ¡t Ä‘Ã¡ sao cho vá»›i hai thÃ nh phá»‘ báº¥t ká»³ luÃ´n tá»“n táº¡i má»™t tuyáº¿n Ä‘Æ°á»ng qua
cÃ¡c con Ä‘Æ°á»ng lÃ¡t Ä‘Ã¡ ná»‘i chÃºng vá»›i nhau vÃ  giÃ¡ trung bÃ¬nh 1 km Ä‘Æ°á»ng lÃ  ráº» nháº¥t. 
Biáº¿t ráº±ng con Ä‘Æ°á»ng thá»© ğ‘– cÃ³ Ä‘á»™ dÃ i ğ‘™ğ‘– km vÃ  Ä‘á»ƒ lÃ¡t Ä‘Ã¡ con Ä‘Æ°á»ng Ä‘Ã³ tá»‘n chi phÃ­ lÃ  ğ‘ğ‘–.
Há»‡ thá»‘ng cÃ¡c con Ä‘Æ°á»ng Ä‘áº£m báº£o sá»± Ä‘i láº¡i giá»¯a hai thÃ nh phá»‘ báº¥t ká»³. 
GiÃ¡ trung bÃ¬nh cá»§a 1 km Ä‘Æ°á»ng trong má»™t phÆ°Æ¡ng Ã¡n lÃ¡t Ä‘Ã¡ Ä‘Æ°á»£c tÃ­nh báº±ng:
Tá»•ng chi phÃ­ lÃ¡t Ä‘Ã¡ cÃ¡c con Ä‘Æ°á»ng trong phÆ°Æ¡ng Ã¡n / Tá»•ng Ä‘á»™ dÃ i cÃ¡c con Ä‘Æ°á»ng Ä‘Æ°á»£c lÃ¡t Ä‘Ã¡ trong phÆ°Æ¡ng Ã¡n
YÃªu cáº§u:. HÃ£y xÃ¡c Ä‘á»‹nh phÆ°Æ¡ng Ã¡n tá»‘i Æ°u Ä‘á»ƒ lÃ¡t Ä‘Ã¡ cÃ¡c con Ä‘Æ°á»ng theo yÃªu cáº§u cá»§a nhÃ  vua.
Dá»¯ liá»‡u: VÃ o tá»« file vÄƒn báº£n PROJECT.INP
âš« DÃ²ng 1: Chá»©a hai sá»‘ nguyÃªn dÆ°Æ¡ng ğ‘›, ğ‘š â‰¤ 104
âš« ğ‘š dÃ²ng tiáº¿p theo, dÃ²ng thá»© ğ‘– chá»©a 4 sá»‘ nguyÃªn dÆ°Æ¡ng ğ‘¢ğ‘–, ğ‘£ğ‘–, ğ‘™ğ‘–, ğ‘ğ‘– (1 â‰¤ ğ‘™ğ‘–, ğ‘ğ‘– â‰¤ 10^5)
Káº¿t quáº£: Ghi ra file vÄƒn báº£n PROJECT.OUT ğ‘› âˆ’ 1 sá»‘ nguyÃªn trÃªn má»™t dÃ²ng lÃ  sá»‘ hiá»‡u cÃ¡c con Ä‘Æ°á»ng trong
phÆ°Æ¡ng Ã¡n tá»‘i Æ°u tÃ¬m Ä‘Æ°á»£c

MY SOLUTION: MINIMUM RATIO SPANNING TREE

Code:
#include <iostream>
#include <algorithm>
#include <vector>
#include <cstdio>
using namespace std;

struct KDL
{
    int x, y, u, v, p;
};

int n, m, x, y, j, dd[10005];
vector<KDL> v;
pair<int,int> djs[10001];

bool cmp(KDL a, KDL b)
{
    return y*a.v-x*a.u < y*b.v-x*b.u;
}

int fset(int x)
{
    if (djs[x].first!=x) return (djs[x].first=fset(djs[x].first));
    return x;
}

void gopcay(int a, int b)
{
    if (djs[a].second>djs[b].second)
        djs[b].first=a;
    if (djs[a].second<djs[b].second)
        djs[a].first=b;
    if (djs[a].second==djs[b].second)
    {
        djs[a].first=b;
        djs[b].second++;
    }
}

void findspanningtree()
{
    sort(v.begin(),v.end(),cmp);
    x=y=0;
    for (int i = 1; i <= n; i++)
    {
        djs[i].first=i;
        djs[i].second=1;
    }
    int d = 0;
    j=0;
    for (int i = 0; i < v.size(); i++)
    {
        int dinh1 = fset(v[i].x), dinh2=fset(v[i].y);
        if (dinh1!=dinh2)
        {
            d++;
            x+=v[i].v;
            y+=v[i].u;
            dd[++j]=v[i].p;
            gopcay(dinh1,dinh2);
        }
        if (d==n-1) break;
    }
}

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    freopen("PROJECT.inp","r",stdin);
    freopen("PROJECT.out","w",stdout);
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        int u, vs, l, c;
        cin >> u >> vs >> l >> c;
        v.push_back({u,vs,l,c,i});
    }
    x = 0, y=1;
    int tx = -1, ty=-1;
    while (x*ty!=y*tx)
    {
        tx=x;
        ty=y;
        findspanningtree();
    }
    for (int i = 1; i <= j; i++)
    {
        cout << dd[i] << " ";
    }
    return 0;
}
